<!-- TITLE: Usability -->
<!-- SUBTITLE: A quick summary of Usability -->

# UX Starts by being Useful
The core of a great user experience is being useful.

![Ux Starts By Being Useful](/uploads/ux-starts-by-being-useful.png "Ux Starts By Being Useful")

# LEMErS

## Learnibility
How easy is it for users to accoplish basic tasks the first time they encounter the design?

## Efficiency
Once the users have learned the design, how easy is it for them to complete tasks?

## Memorability
When users return to the design, how easily can they reestabilsh proficiency?

**Designing for memorability**
* Use familiar design patterns (i.e [you should already know how to use it](https://www.smashingmagazine.com/2012/09/you-already-know-how-to-use-it/))
* Begin with core functionality and save advanced tips for later functionality

## Errors
* How many errors do the users make?
* How severe are these errors?
* How easily can they recover from these errors?

## Satisfaction
How easy is the design to use?

![Satisfaction](/uploads/satisfaction.png "Satisfaction")

# 10 Usability Heuristics

## Visibility of system status
The system should always keep the user informed of whats going on, through appropriate feedback within a resonable time

* Progress bars
* Position in a steps wizard

## System-World Match
The system should speak the users language with words, phrases and concepts familiar to the user, rather than system orientated language.

* Iconography (e.g. a bin for delete)
* Useage of real world items (e.g. a calculator with buttons similar to a real world calculator)


## User Control and Freedom
Users need to leave an undesired state without recieving unwanted dialogue. Support of undo and redo.

## Consistency and Standards
Users should not have to wonder whether different words, situations or actions mean the same thing.

* Consistent language
* Events should look and sound similar
* Follow platform conventions (ios app vs android app, desktop web browser)

## Error prevention
Attempt to eliminate any error prone situations but have good error messages in the event that an error occurs. Enable confirmations before completing critical actions.

* "Do you really want to delete x?"

## Recogition over recall
Don't make the user remeber things. Minimise the users congitive load by making options visible and provide clear instructions when necessary.

## Flexibility and efficiency of use

* Support both novice and advanced users
* Allow users to tailor certain actions

## Minimal design
The design should not contain more information than necessary

## Errors, help users recognize, diagnose, and recover
* Communicate errors in plain language
* Indicate the problem and suggest a solution

## Help and documentation
* It's always better if a system can be developed without the need of help or knowledge base, however it may be necessary
* Any information should be easy to search and focused on the users task at hand
* A concrete list of steps should be created without being too large

